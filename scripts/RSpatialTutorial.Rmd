---
title: "Terra_Intro"
author: "Jenny Cribbs"
date: "2026-02-01"
output: html_document
---

```{r}
name <- LETTERS[1:10]
longitude <- c(-116.7, -120.4, -116.7, -113.5, -115.5,
               -120.8, -119.5, -113.7, -113.7, -110.7)
latitude <- c(45.3, 42.6, 38.9, 42.1, 35.7, 38.9,
              36.2, 39, 41.6, 36.9)
stations <- cbind(longitude, latitude)
# Simulated rainfall data
set.seed(0)
precip <- round((runif(length(latitude))*10)^3)

psize <- 1 + precip/500
plot(stations, cex=psize, pch=20, col='red', main='Precipitation')
# add names to plot
text(stations, name, pos=4)
# add a legend
breaks <- c(100, 250, 500, 1000)
legend.psize <- 1+breaks/500
legend("topright", legend=breaks, pch=20, pt.cex=legend.psize, col='red', bg='gray')
```
```{r}
lon <- c(-116.8, -114.2, -112.9, -111.9, -114.2, -115.4, -117.7)
lat <- c(41.3, 42.9, 42.4, 39.8, 37.6, 38.3, 37.6)
x <- cbind(lon, lat)
plot(stations, main='Precipitation')
polygon(x, col='blue', border='light blue')
lines(stations, lwd=3, col='red')
points(x, cex=2, pch=20)
points(stations, cex=psize, pch=20, col='red', main='Precipitation')
```
```{r}
library(terra)
# stick coordinates together
lonlat <- cbind(longitude, latitude)
# make them into a spatial vector
pts <- vect(lonlat)
# check objec type: SpatVector
class(pts)
# attirbutes
pts
# look at what's in it
geom(pts)
```
```{r}
# assign a coordinate reference system 
crdref <- "+proj=longlat +datum=WGS84"
pts <- vect(lonlat, crs=crdref)
pts
# check coordinate reference system 
crs(pts)
```
```{r}
 # Generate random precipitation values, same quantity as points
precipvalue <- runif(nrow(lonlat), min=0, max=100)
df <- data.frame(ID=1:nrow(lonlat), precip=precipvalue)
# combine the spat vector with the dataframe
ptv <- vect(lonlat, atts=df, crs=crdref)
```

Can make spatial objects from scratch:

```{r}
# make a line
lon <- c(-116.8, -114.2, -112.9, -111.9, -114.2, -115.4, -117.7)
lat <- c(41.3, 42.9, 42.4, 39.8, 37.6, 38.3, 37.6)
lonlat <- cbind(id=1, part=1, lon, lat)
lonlat
##      id part    lon  lat
## [1,]  1    1 -116.8 41.3
## [2,]  1    1 -114.2 42.9
## [3,]  1    1 -112.9 42.4
## [4,]  1    1 -111.9 39.8
## [5,]  1    1 -114.2 37.6
## [6,]  1    1 -115.4 38.3
## [7,]  1    1 -117.7 37.6
lns <- vect(lonlat, type="lines", crs=crdref)
lns
##  class       : SpatVector
##  geometry    : lines
##  dimensions  : 1, 0  (geometries, attributes)
##  extent      : -117.7, -111.9, 37.6, 42.9  (xmin, xmax, ymin, ymax)
##  coord. ref. : +proj=longlat +datum=WGS84 +no_defs
```
```{r}
# make a polygon
pols <- vect(lonlat, type="polygons", crs=crdref)
pols
##  class       : SpatVector
##  geometry    : polygons
##  dimensions  : 1, 0  (geometries, attributes)
##  extent      : -117.7, -111.9, 37.6, 42.9  (xmin, xmax, ymin, ymax)
##  coord. ref. : +proj=longlat +datum=WGS84 +no_defs
```
```{r}
# make a map
plot(pols, las=1)
plot(pols, border='blue', col='yellow', lwd=3, add=TRUE)
points(pts, col='red', pch=20, cex=3)
```

## Raster Data

```{r}
# create an (empty raster) from scratch
r <- rast(ncol=10, nrow=10, xmin=-150, xmax=-80, ymin=20, ymax=60)
r

# add random values
values(r) <- runif(ncell(r))
r

```

```{r}
# overwrite with sequential values
values(r) <- 1:ncell(r)
r
```

```{r}
plot(r)
```

```{r}
plot(r)
# add polygon and points
lon <- c(-116.8, -114.2, -112.9, -111.9, -114.2, -115.4, -117.7)
lat <- c(41.3, 42.9, 42.4, 39.8, 37.6, 38.3, 37.6)
lonlat <- cbind(id=1, part=1, lon, lat)
pts <- vect(lonlat)
pols <- vect(lonlat, type="polygons", crs="+proj=longlat +datum=WGS84")
points(pts, col="red", pch=20, cex=3)
lines(pols, col="blue", lwd=2)
```

```{r}
# create a multi-layer object using c
r2 <- r * r
r3  <- sqrt(r)
s <- c(r, r2, r3)
s
```
## Reading and Writing Spatial Data

```{r}
filename <- system.file("ex/lux.shp", package="terra")
basename(filename)
```

```{r}
# read in the lux.shp file loaded above
s <- vect(filename) # makes a SpatVector file from the data in the shapefile
s
```

```{r}
# write spatial data
outfile <- "shp_test.shp" 
writeVector(s, outfile, overwrite=TRUE) # added to working directory
```

```{r}
# file.remove (or unlink) to remove from working directory
ff <- list.files(patt="^shp_test")
file.remove(ff)

```

```{r}
# find some example raster data
f <- system.file("ex/logo.tif", package="terra")
basename(f)
```

```{r}
# load example raster into r
r <- rast(f)
r
```

```{r}
# x has 3 layers--can separate the layers
r2 <- r[[2]]
r2
```

```{r}
# write out raster data
x <- writeRaster(r, "test_output.tif", overwrite=TRUE)
x
```
```{r}
# load a spatial file built into R
f <- system.file("ex/lux.shp", package="terra")
p <- vect(f)
p
# check crs
crs(p)
```
```{r}
# creates pp as a copy of p
pp <- p
# removes the crs of pp
crs(pp) <- ""
crs(pp)

# robinson projection
newcrs <- "+proj=robin +datum=WGS84"
# project the p object using the robinson projection
rob <- terra::project(p, newcrs)
rob
```

```{r}
# backtransform to latitude/longitude
p2 <- terra::project(rob, "+proj=longlat +datum=WGS84")

```


Projecting raster data can affect the cell values, so generally project vector data rather than raster data. 

```{r}
r <- rast(xmin=-110, xmax=-90, ymin=40, ymax=60, ncols=40, nrows=40)
values(r) <- 1:ncell(r)
r
plot(r)
```

```{r}
# transform into the newcrs
newcrs
crs(r)
pr1 <- terra::project(r, newcrs)
crs(pr1)
plot(pr1)
```

However, this does not match the grid of the prior SpatRaster. 

```{r}
x <- rast(pr1)
# set the cell size
res(x) <- 200000
pr3 <- terra::project(r, x)
pr3
plot(pr3)
```
Equal area projections are usually best for raster analysis, especially with count data.

## Manipulating Vector Data

```{r}
# basic plot
plot(p, "NAME_2")
```
```{r}
# extra the attributes as a dataframe
d <- as.data.frame(p)
head(d)
```

```{r}
# extract the geometry as a matrix
g <- geom(p) # not as common
head(g)
```

```{r}
# extract geometry as well-known text
g <- geom(p, wkt = TRUE)
substr(g, 1, 50)
```
```{r}
# extract a variable
p$NAME_2 # returns a vector
```
```{r}
# subset a SpatVector
p[, "NAME_2"] # returns a SpatVector with one variable
```
```{r}
# add a new variable to a SpatVector
set.seed(0)
p$lets <- sample(letters, nrow(p)) # adds a variable with random letters
p
```

```{r}
# get the perimeter
perim(p)
```

```{r}
# assign a new value to an existing variable
p$lets <- sample(LETTERS, nrow(p))
head(p)
```

```{r}
# remove a variable
p$lets <- NULL
head(p)
```

```{r}
# append an attributes table with merge (or cbind if order is identical)
dfr <- data.frame(District=p$NAME_1, Canton=p$NAME_2, Value=round(runif(length(p), 100, 1000)))
dfr <- dfr[order(dfr$Canton), ]
pm <- merge(p, dfr, by.x=c('NAME_1', 'NAME_2'), by.y=c('District', 'Canton'))
pm
head(pm)
```
```{r}
# selecting records
i <- which(p$NAME_1 == 'Grevenmacher')
g <- p[i,]
g
```

Can also select interactively (see ?sel and ?click).

```{r}
z <- rast(p)
dim(z) <- c(2,2)
values(z) <- 1:4
names(z) <- 'Zone'
# coerce SpatRaster to SpatVector polygons
z <- as.polygons(z)
z
```

```{r}
# z2 is one of the 4 polygons above
z2 <- z[2,]
plot(p)
plot(z, add=TRUE, border='blue', lwd=5)
plot(z2, add=TRUE, border='red', lwd=2, col='red')
```
```{r}
# append SpatVector objects of the same type
b <- rbind(p, z)
head(b)
tail(b)
```

```{r}
# aggregate by the first level subdivisions
pa <- aggregate(p, by = 'NAME_1')
za <- aggregate(z)
plot(za, col='light gray', border='light gray', lwd=5)
plot(pa, add=TRUE, col=rainbow(3), lwd=3, border='white')
```
```{r}
zag <- aggregate(z, dissolve=FALSE)
zag
plot(zag, col="light gray")
```

```{r}
# split up aggregated parts
zd <- disagg(zag)
zd
```
```{r}
# erase part of a SpatVector
e <- erase(p, z2)
plot(e)
```
```{r}
# intersect SpatVectors
i <- intersect(p, z2)
plot(i)
```
```{r}
# crop to select within a bounding box
e <- ext(6, 6.4, 49.7, 50)
pe <- crop(p, e)
plot(p)
plot(e, add=TRUE, lwd=3, col="red")
plot(pe, col='light blue', add=TRUE)
plot(e, add=TRUE, lwd=3, border="blue")

```
```{r}
# get the union of two SpatVectors
u <- union(p, z)
u
```

```{r}
# plot shows polygons for each unique combination of polygon and attribute
set.seed(5)
plot(u, col=sample(rainbow(length(u))))
```
```{r}
# cover returns the intersection of vector objects and attributes of both
cov <- cover(p, z[c(1,4),])
cov
plot(cov)
```
```{r}
# the symmetrical difference of two SpatVectors
dif <- symdif(z, p)
plot(dif, col=rainbow(length(dif)))
```
```{r}
# point in polygon querry
pts <- matrix(c(6, 6.1, 5.9, 5.7, 6.4, 50, 49.9, 49.8, 49.7, 49.5), ncol=2)
spts <- vect(pts, crs=crs(p))
plot(z, col='light blue', lwd=2)
points(spts, col='light gray', pch=20, cex=6)
text(spts, 1:nrow(pts), col='red', font=2, cex=1.5)
lines(p, col='blue', lwd=2)
```
```{r}
# extract for querries between SpatVector and SpatRaster (or another SpatVector)
extract(spts, p)
```
```{r}
extract(spts, z)
```
## Creating and Manipulating Rasters

```{r}
# create a SpatRaster with default parameters
x <- rast()
x
```
```{r}
# create with different parameters
x <- rast(ncol=36, nrow=18, xmin=-1000, xmax=1000, ymin=-100, ymax=900)
# check resolution
res(x)
# change resolution
res(x) <- 100
res(x)
```

```{r}
# changing the number of columns affects the resolution
ncol(x)
ncol(x) <- 18
ncol(x)
res(x)
```

```{r}
# set the crs
crs(x) <- "+proj=utm +zone=48 +datum=WGS84"
x
```

```{r}
# create an empty raster
r <- rast(ncol = 10, nrow = 10)
ncell(r)
hasValues(r)
```

```{r}
# add sequential values
values(r) <- 1:ncell(r)
r
plot(r)
```

```{r}
# another example with random values
set.seed(0)
values(r) <- runif(ncell(r))
hasValues(r)
sources(r)
values(r)[1:10]
plot(r, main='Raster with 100 cells')
```

```{r}
res(r)
dim(r)
ext(r)
```

```{r}
# change the maximum x coordinate
xmax(r) <- 0
hasValues(r)
res(r)
dim(r)

```

```{r}
# change the number of columns
ncol(r) <- 6
hasValues(r) # values disappear
res(r)
dim(r)
xmax(r)
```

Can use raster files in GeoTiff, ESRI, ENVI, and ERDAS formats rather than creating from scratch. Can work with large files in chunks. 

```{r}
# get an example raster file installed with terra
filename <- system.file("ex/elev.tif", package="terra")
basename(filename)
# read the file into R
r <- rast(filename)
sources(r)
hasValues(r)
plot(r, main = "Example SpatRaster Showing Elevation")
```

```{r}
# create three identical rasters
r1 <- r2 <- r3 <- rast(nrow=10, ncol=10)
# Assign random cell values
values(r1) <- runif(ncell(r1))
values(r2) <- runif(ncell(r2))
values(r3) <- runif(ncell(r3))
# combine the three rasters
s <- c(r1, r2, r3)
s
nlyr(s)
```

```{r}
# create a multilayer object from a file
filename <- system.file("ex/logo.tif", package="terra")
basename(filename)
# read it into R
b <- rast(filename)
b
nlyr(b)
```
```{r}
# extract the second layer
r <- b[[2]]
```

## Raster Algebra

```{r}
# create a raster
r <- rast(ncol=10, nrow=10)
values(r) <- 1:ncell(r)
# raster algebra
s <- r + 10
s <- sqrt(s)
s <- s * r + 5
values(r) <- runif(ncell(r))
r <- round(r)
r <- r == 1
```

```{r}
# replacement functions
#Not yet implemented
s[r] <- -0.5
s[!r] <- 5
s[s == 5] <- 15
```

```{r}
# shorter vectors objects are recycled for operations with multiple layers
r <- rast(ncol=5, nrow=5)
values(r) <- 1
s <- c(r, r+1)
q <- c(r, r+2, r+4, r+6)
x <- r + s + q
x
```
```{r}
# summary functions return a SpatRaster
a <- mean(r,s,10)
b <- sum(r,s)
st <- c(r, s, a, b)
sst <- sum(st)
sst
```
```{r}
# global uses a single number to summarize values in each layer
global(st, 'sum')
```

```{r}
global(sst, 'sum')
```

Can create a bounding box by plotting a raster and using drawExtent to droaw the bounding box for the crop function. Aggregate dna disagg change the cell sizes. Resample is good for keeping the same cell size, but shifting cell centers. Shift, extent, trim, and extend good for small changes to make nearly the same rasters work together.

```{r}
# aggregate then disaggretate
r <- rast()
values(r) <- 1:ncell(r)
ra <- aggregate(r, 20)
rd <- disagg(ra, 20)

# crop and merge
r1 <- crop(r, ext(-50,0,0,30))
r2 <- crop(r, ext(-10,50,-20, 10))
m <- merge(r1, r2, filename="test.tif", overwrite=TRUE)
plot(m)
```
Pickup with Focal functions
